				;			@ /0000 ;
0000 a218		;	programa		SC	main	;
0002 0000		;	zero			K	=0		;
0004 0001		;	one				K	=1		;
0006 0002		;	two				K	=2		;
0008 000a		;	ten				K 	=10		;
000a 0010		;	sixteen			K	=16		;
000c 0ff0		;	STOP			K   /0FF0	;

000e ffff		;	FFFF			K	/FFFF	    ; Base de representação

0010 0030		;	ascii_offset	K	/30			; Offset para o código de um número na tabela ASCII
0012 002d		;	ascii_minus		K	/2D			; Sinal de menos em ASCII
0014 000d		;	ascii_cr		K	/D			; Carriage return em ASCII
0016 000a		;	ascii_lf		K	/A			; Line feed em ASCII


0018 0000		;	output_number	K 	=0			; Número para ser impresso
001a 0000		;	o_temp1			K	=0			; Guarda o valor da última dezena
001c 0001		;	o_temp2			K	=1			; Indicador da dezena

001e 0000		;	output		JP	/0000				;
0020 8008		;				LD	ten					; Inicialização
0022 901c		;				MM	o_temp2				;
0024 8018		;				LD	output_number		; 
0026 202a		;				JN	o_negative			; Número negativo
0028 0036		;				JP  o_start				; Número posítivo
002a 8012		;	o_negative	LD	ascii_minus			; Caso contrário imprime "-"
002c e100		;				PD	/0100				;
002e 800e		;				LD	FFFF				; E inverte o número
0030 5018		;				-	output_number		;
0032 4004		;				+	one					;
0034 9018		;				MM	output_number		;
0036 901a		;	o_start		MM	o_temp1				;
0038 8018		;	o_loop		LD	output_number		; Carrega o número
003a 701c		;				/	o_temp2				;
003c 1048		;				JZ	o_print				; Imprime se é o número mais a esquerda.
003e 901a		;				MM	o_temp1				; Se não, guarda o número 
0040 801c		;				LD	o_temp2				; Aumenta a casa decimal
0042 6008		;				*	ten					;
0044 901c		;				MM	o_temp2				;
0046 0038		;				JP	o_loop				; E volta para o loop
0048 801a		;	o_print		LD	o_temp1				; Impressão do número
004a 4010		;				+	ascii_offset		;
004c e100		;				PD	/0100				;
004e 801c		;				LD	o_temp2				; Verifica se é o último número
0050 7008		;				/	ten					;
0052 901c		;				MM	o_temp2				;
0054 5004		;				-	one					;
0056 106c		;				JZ	o_end				; Vai para o final, se ímprimiu tudo
0058 801a		;				LD	o_temp1				;
005a 601c		;				*	o_temp2				;
005c 901a		;				MM	o_temp1				;
005e 8018		;				LD	output_number		; Atualiza o número para impressão
0060 501a		;				-	o_temp1				;
0062 9018		;				MM	output_number		;
0064 901a		;				MM	o_temp1				;
0066 8008		;				LD	ten					;
0068 901c		;				MM	o_temp2				;
006a 0038		;				JP	o_loop				; Imprime o próximo caracter

006c b01e		;	o_end		RS	output				; Final da rotina


006e 0000		;	input_number	K	=0				; Variável de retorno da rotina
0070 0000		;	i_negative		K	=0				; Número digitado é negativo
0072 0000		;	i_temp			K	=0				; Variáveis temporárias
0074 0000		;	i_temp2			K	=0				;

0076 0000		;	input		JP	/0000				;
0078 8002		;				LD  zero				; Inicialização
007a 906e		;				MM	input_number		;
007c 9070		;				MM	i_negative			;
007e 9072		;				MM	i_temp				;
0080 9074		;				MM	i_temp2				;
0082 d000		;				GD	/0000				; Leitura de número negativo
0084 9072		;				MM	i_temp				; Guarda caracteres lidos em i_temp
0086 700a		;				/	sixteen				; Obtém o primeiro caracter
0088 700a		;				/	sixteen				; 
008a 9074		;				MM	i_temp2				;
008c 5012		;				-	ascii_minus			; Verifica se número digitado é negativo
008e 1092		;				JZ	set_i_negative		;
0090 00a2		;				JP	1st_char			; Não é negativo, lê como número
0092 8004		;	set_i_negative	LD	one				; Carrega o i_negative com FFFF
0094 9070		;				MM	i_negative			;
0096 00ba		;				JP	2nd_char			; Lê o segundo caracter
0098 d000		;	i_loop		GD	/0000				; Loop de leitura
009a 9072		;				MM	i_temp				; Guarda caracteres lidos em i_temp
009c 700a		;				/	sixteen				; Obtém o primeiro caracter
009e 700a		;				/	sixteen				; 
00a0 9074		;				MM	i_temp2				;
00a2 5014		;	1st_char	-	ascii_cr			; Verifica se é o fim (ascii \d ou \a)
00a4 10e2		;				JZ	i_end				; 
00a6 8074		;				LD	i_temp2				;
00a8 5016		;				- 	ascii_lf			;
00aa 10e2		;				JZ	i_end				;
00ac 806e		;				LD	input_number		; Não é o último caracter
00ae 6008		;				*	ten					; Aumenta uma dezena no resultado
00b0 906e		;				MM	input_number		;	
00b2 8074		;				LD	i_temp2				; Converte caracter lido em número
00b4 5010		;				-	ascii_offset		;
00b6 406e		;				+	input_number		; Soma no resultado de retorno
00b8 906e		;				MM	input_number		; Atualiza o resultado de retorno
00ba 8074		;	2nd_char	LD	i_temp2				; Obtém o segundo caracter
00bc 600a		;				*	sixteen				;
00be 600a		;				*	sixteen				;
00c0 9074		;				MM	i_temp2				;
00c2 8072		;				LD	i_temp				;
00c4 5074		;				-	i_temp2				;
00c6 9074		;				MM	i_temp2				;
00c8 5014		;				-	ascii_cr			; Verifica se é o fim (ascii \d ou \a)
00ca 10e2		;				JZ	i_end				; 
00cc 8074		;				LD	i_temp2				;
00ce 5016		;				- 	ascii_lf			;
00d0 10e2		;				JZ	i_end				;
00d2 806e		;				LD	input_number		; Não é o último caracter
00d4 6008		;				*	ten					; Aumenta uma dezena no resultado
00d6 906e		;				MM	input_number		;	
00d8 8074		;				LD	i_temp2				; Converte caracter lido em número
00da 5010		;				-	ascii_offset		;
00dc 406e		;				+	input_number		; Soma no resultado de retorno
00de 906e		;				MM	input_number		; Atualiza o resultado de retorno
00e0 0098		;				JP	i_loop				; Lê o proximo caracter
00e2 8070		;	i_end		LD	i_negative			; Transforma em negativo se negativo
00e4 10ec		;				JZ  i_return			;
00e6 8002		;				LD	zero				;
00e8 506e		;				-	input_number		;
00ea 906e		;				MM	input_number		;
00ec 806e		;	i_return	LD	input_number		;
00ee b076		;				RS	input				;

00f0 8000		;	load_inst       LD  /0000				; Instrução para o acesso indireto
00f2 9000		;	store_inst		MM	/0000				; Instrução para store indireto
00f4 b000		;	return_inst		RS	/0000				; Instrução para retorno indireto
00f6 0000		;	pos_param       K   =0					; Posição do parâmetro da função
                                      
00f8 0000		;	load_ra_pos  	JP  /0000               ; Ponto de entrada da subrotina
00fa 800c		;	                LD  STOP                ; Carrega topo da pilha do R.A.
00fc 5006		;	                -   two       			; Diminui um endereço na pilha do R.A.
00fe 50f6		;	                -   pos_param			; Accumulador com o endereço correto
0100 40f0		;	                +   load_inst  			; Here's the magic: Cria instrução nova!
0102 9104		;	                MM  hack				; Armazena como a PROXIMA INSTRUCAO! 
0104 0000		;	hack			K  /0                   ; Reservado para guardar a instrução recém-montada
0106 b0f8		;	                RS load_ra_pos		    ; Thanks to Débora for this piece of gold

0108 0000		;	store_ra_pos	JP	/0000				;
010a 800c		;					LD  STOP                ; Carrega topo da pilha do R.A.
010c 5006		;	                -   two       			; Diminui um endereço na pilha do R.A.
010e 50f6		;	                -   pos_param			; Accumulador com o endereço correto
0110 40f2		;	                +   store_inst  		; Here's the magic: Cria instrução nova!
0112 9114		;	                MM  hack2				; Armazena como a PROXIMA INSTRUCAO! 
0114 0000		;	hack2			K  /0                   ; Reservado para guardar a instrução recém-montada
0116 b108		;	                RS store_ra_pos		    ;

0118 0000		;	ra_tam			K   =0			;
011a 0190		;	ra_end			K	=0400		;

011c 0000		;	cria_ra			JP  /0000		;
011e 800c		;					LD	STOP		;
0120 4006		;					+	two			;
0122 900c		;					MM	STOP		;
0124 8002		;					LD	zero		;
0126 90f6		;					MM	pos_param    ;
0128 811a		;					LD	ra_end		 ;
012a a108		;					SC	store_ra_pos ;
012c 800c		;					LD  STOP		;
012e 4118		;					+	ra_tam		;
0130 900c		;					MM	STOP		;
0132 b11c		;					RS	cria_ra		;

				;					@ /0200

; Function prettyprint
0200 0000		;	F0			JP  /0000		;
0202 8a02		;				LD  K0		; Carrega variavel do RA
0204 90f6		;				MM  pos_param		;
0206 a0f8		;				SC  load_ra_pos		;
0208 9018		;				MM  output_number	;
020a a01e		;				SC  output			;
020c 8a02		;				LD  K0		; Carrega variavel do RA
020e 90f6		;				MM  pos_param		;
0210 a0f8		;				SC  load_ra_pos		;
0212 40f4		;				+  return_inst		;
0214 9216		;				MM  _F0		;
0216 0000		;	_F0			K  /0000		; Guarda o endereço de retorno
; End of function prettyprint

0218 0000		;	main		JP  /0000		;
021a a076		;				SC  input	; Comando de input
021c 9a04		;				MM  V1		;
021e 8a06		;				LD  K1		; Cria registro de ativacao
0220 9118		;				MM ra_tam		; 
0222 8a08		;				LD  K2		;
0224 911a		;				MM  ra_end		;
0226 a11c		;				SC  cria_ra	;
0228 a200		;				SC  F0		; Chama funcao
022a 8a04		;				LD  V1		; Atribuicao de variavel
022c 9a04		;				MM  V1		;
022e c000		;				HM  /00		;

				;			 @ /0A00
0a00 0000		;	V0			K  =0		; Declaracao de variavel
0a02 0001		;	K0			K  =1		; Declaracao de constante
0a04 0000		;	V1			K  =0		; Declaracao de variavel
0a06 0004		;	K1			K  =4		; Declaracao de constante
0a08 0004		;	K2			K  =4		; Declaracao de constante
